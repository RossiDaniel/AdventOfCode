
module Puzzle5 where

info :: [Int]
info = [3,225,1,225,6,6,1100,1,238,225,104,0,1002,148,28,224,1001,224,-672,224,4,224,1002,223,8,223,101,3,224,224,1,224,223,223,1102,8,21,225,1102,13,10,225,1102,21,10,225,1102,6,14,225,1102,94,17,225,1,40,173,224,1001,224,-90,224,4,224,102,8,223,223,1001,224,4,224,1,224,223,223,2,35,44,224,101,-80,224,224,4,224,102,8,223,223,101,6,224,224,1,223,224,223,1101,26,94,224,101,-120,224,224,4,224,102,8,223,223,1001,224,7,224,1,224,223,223,1001,52,70,224,101,-87,224,224,4,224,1002,223,8,223,1001,224,2,224,1,223,224,223,1101,16,92,225,1101,59,24,225,102,83,48,224,101,-1162,224,224,4,224,102,8,223,223,101,4,224,224,1,223,224,223,1101,80,10,225,101,5,143,224,1001,224,-21,224,4,224,1002,223,8,223,1001,224,6,224,1,223,224,223,1102,94,67,224,101,-6298,224,224,4,224,102,8,223,223,1001,224,3,224,1,224,223,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,108,677,677,224,102,2,223,223,1005,224,329,101,1,223,223,1107,677,226,224,102,2,223,223,1006,224,344,101,1,223,223,1107,226,226,224,102,2,223,223,1006,224,359,101,1,223,223,1108,677,677,224,102,2,223,223,1005,224,374,101,1,223,223,8,677,226,224,1002,223,2,223,1005,224,389,101,1,223,223,108,226,677,224,1002,223,2,223,1006,224,404,1001,223,1,223,107,677,677,224,102,2,223,223,1006,224,419,101,1,223,223,1007,226,226,224,102,2,223,223,1005,224,434,101,1,223,223,1007,677,677,224,102,2,223,223,1005,224,449,1001,223,1,223,8,677,677,224,1002,223,2,223,1006,224,464,101,1,223,223,1108,677,226,224,1002,223,2,223,1005,224,479,101,1,223,223,7,677,226,224,1002,223,2,223,1005,224,494,101,1,223,223,1008,677,677,224,1002,223,2,223,1006,224,509,1001,223,1,223,1007,226,677,224,1002,223,2,223,1006,224,524,1001,223,1,223,107,226,226,224,1002,223,2,223,1006,224,539,1001,223,1,223,1107,226,677,224,102,2,223,223,1005,224,554,101,1,223,223,1108,226,677,224,102,2,223,223,1006,224,569,101,1,223,223,108,226,226,224,1002,223,2,223,1006,224,584,1001,223,1,223,7,226,226,224,1002,223,2,223,1006,224,599,101,1,223,223,8,226,677,224,102,2,223,223,1005,224,614,101,1,223,223,7,226,677,224,1002,223,2,223,1005,224,629,101,1,223,223,1008,226,677,224,1002,223,2,223,1006,224,644,101,1,223,223,107,226,677,224,1002,223,2,223,1005,224,659,1001,223,1,223,1008,226,226,224,1002,223,2,223,1006,224,674,1001,223,1,223,4,223,99,226]

example4 :: [Int]
example4 = [3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99]

type State = ([Int],Int)

example :: [Int]
example = [1,9,10,3,2,3,11,0,99,30,40,50]

example1 :: [Int]
example1 = [1,1,1,4,99,5,6,0,99]

example2 :: [Int]
example2 = [2,4,4,5,99,0]

int2arr :: Int -> [Int]
int2arr 0 = []
int2arr x = int2arr (x `div` 10) ++ [x `mod` 10]

zeros :: Int -> [Int]
zeros 0 = []
zeros x = 0 : zeros (x-1)

int2istr :: Int -> [Int]
int2istr xs = reverse ((zeros (5 - (length exp))) ++ exp)
            where
                exp = int2arr xs

mode :: [Int] -> Int -> Int -> Int
mode xs i m | m == 0    = xs!!(xs!!i)
            | otherwise = xs!!i 

somma :: [Int] -> Int -> [Int] -> [Int]
somma xs i istr= (take ((xs!!(i+3))) xs) ++ [(mode xs (i+1) (istr!!2)) + (mode xs (i+2) (istr!!3))] ++ (drop ((xs!!(i+3))+1) xs)

prodotto :: [Int] -> Int -> [Int] -> [Int]
prodotto xs i istr= (take ((xs!!(i+3))) xs) ++ [(mode xs (i+1) (istr!!2)) * (mode xs (i+2) (istr!!3))] ++ (drop ((xs!!(i+3))+1) xs)

inputistr :: [Int] -> Int -> [Int] -> [Int]
inputistr xs i inp = (take ((xs!!(i+1))) xs) ++ [(head inp)] ++ (drop ((xs!!(i+1))+1) xs)

outputistr :: [Int] -> Int -> [Int] -> Int
outputistr xs i istr = mode xs (i+1) (istr!!2)

substitute :: [Int] -> Int -> Int -> [Int]
substitute xs i v = (take i xs) ++ [v] ++ (drop (i+1) xs)

op :: [Int] -> [Int] -> Int -> [([Int],[Int],Int,[Int],[Int])]
op inp xs i  | head istr == 1 = (inp,xs,i,istr,[]):(op inp (somma xs i istr) (i+4))
             | head istr == 2 = (inp,xs,i,istr,[]):(op inp (prodotto xs i istr) (i+4))
             | head istr == 3 = (inp,xs,i,istr,[]):(op (drop 1 inp) (inputistr xs i inp) (i+2))
             | head istr == 4 = (inp,xs,i,istr,[(outputistr xs i istr)]):(op inp xs (i+2))
             | head istr == 5 = if (mode xs (i+1) (istr!!2)) /= 0 then (inp,xs,i,istr,[]):(op inp xs (mode xs (i+2) (istr!!3)))  else (inp,xs,i,istr,[]):(op inp xs (i+3)) 
             | head istr == 6 = if (mode xs (i+1) (istr!!2)) == 0 then (inp,xs,i,istr,[]):(op inp xs (mode xs (i+2) (istr!!3)))  else (inp,xs,i,istr,[]):(op inp xs (i+3)) 
             | head istr == 7 = if (mode xs (i+1) (istr!!2)) < (mode xs (i+2) (istr!!3)) then (inp,xs,i,istr,[]):(op inp (substitute xs (xs!!(i+3)) 1) (i+4))  else (inp,xs,i,istr,[]):(op inp (substitute xs (xs!!(i+3)) 0) (i+4)) 
             | head istr == 8 = if (mode xs (i+1) (istr!!2)) == (mode xs (i+2) (istr!!3)) then (inp,xs,i,istr,[]):(op inp (substitute xs (xs!!(i+3)) 1) (i+4))  else (inp,xs,i,istr,[]):(op inp (substitute xs (xs!!(i+3)) 0) (i+4)) 
             | otherwise    = [(inp,xs,i,istr,[])]
             where
                istr = int2istr (xs!!i)

--memory :: Int -> Int -> [Int] -> [Int]
--memory x y xs = op ((take 1 xs) ++ [x] ++ [y] ++ (drop 3 xs)) 0

--result = [(x,y) | x <- [1..100], y <- [1..100], (((memory x y info)!!0) == 19690720)]  

mihai :: [Int]
mihai = [3,52,1001,52,-5,52,3,53,1,52,56,54,1007,54,5,55,1005,55,26,1001,54,-5,54,1105,1,12,1,53,54,53,1008,54,0,55,1001,55,1,55,2,53,55,53,4,53,1001,56,-1,56,1005,56,6,99,0,0,0,0,10]

examplet :: [Int]
examplet = [3,26,1001,26,-4,26,3,27,1002,27,2,27,1,27,26,27,4,27,1001,28,-1,28,1005,28,6,99,0,0,5]
